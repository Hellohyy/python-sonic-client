<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>sonic.client API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>sonic.client</code> module</h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">from enum import Enum
import socket
import re


class SonicServerError(Exception):
    &#34;&#34;&#34;Generic Sonic Server exception&#34;&#34;&#34;
    pass


class ChannelError(Exception):
    &#34;&#34;&#34;Sonic Channel specific exception&#34;&#34;&#34;
    pass


# Commands available on all channels + START that&#39;s available on the uninitialized channel
COMMON_CMDS = [
    &#39;START&#39;,
    &#39;PING&#39;,
    &#39;HELP&#39;,
    &#39;QUIT&#39;
]

# Channels commands
ALL_CMDS = {
    # FIXME: unintialized entry isn&#39;t needed anymore.
    &#39;UNINITIALIZED&#39;: [
        *COMMON_CMDS,
    ],
    &#39;ingest&#39;: [
        *COMMON_CMDS,
        # PUSH &lt;collection&gt; &lt;bucket&gt; &lt;object&gt; &#34;&lt;text&gt;&#34; [LANG(&lt;locale&gt;)]?
        &#39;PUSH&#39;,
        &#39;POP&#39;,     # POP &lt;collection&gt; &lt;bucket&gt; &lt;object&gt; &#34;&lt;text&gt;&#34;
        &#39;COUNT&#39;,   # COUNT &lt;collection&gt; [&lt;bucket&gt; [&lt;object&gt;]?]?
        &#39;FLUSHC&#39;,  # FLUSHC &lt;collection&gt;
        &#39;FLUSHB&#39;,  # FLUSHB &lt;collection&gt; &lt;bucket&gt;
        &#39;FLUSHO&#39;,  # FLUSHO &lt;collection&gt; &lt;bucket&gt; &lt;object&gt;
    ],
    &#39;search&#39;: [
        *COMMON_CMDS,
        # QUERY &lt;collection&gt; &lt;bucket&gt; &#34;&lt;terms&gt;&#34; [LIMIT(&lt;count&gt;)]? [OFFSET(&lt;count&gt;)]? [LANG(&lt;locale&gt;)]?
        &#39;QUERY&#39;,
        &#39;SUGGEST&#39;,  # SUGGEST &lt;collection&gt; &lt;bucket&gt; &#34;&lt;word&gt;&#34; [LIMIT(&lt;count&gt;)]?
    ],
    &#39;control&#39;: [
        *COMMON_CMDS,
        &#39;TRIGGER&#39;,  # TRIGGER [&lt;action&gt;]?
    ]
}

# snippet from asonic code.


def quote_text(text):
    &#34;&#34;&#34;Quote text and normalize it in sonic protocol context.

    Arguments:
        text str -- text to quote/escape

    Returns:
        str -- quoted text
    &#34;&#34;&#34;
    if text is None:
        return &#34;&#34;
    return &#39;&#34;&#39; + text.replace(&#39;&#34;&#39;, &#39;\\&#34;&#39;).replace(&#39;\r\n&#39;, &#39; &#39;) + &#39;&#34;&#39;


def is_error(response):
    &#34;&#34;&#34;Check if the response is Error or not in sonic context.

    Errors start with `ERR`
    Arguments:
        response {str} -- response string

    Returns:
        [bool] -- true if response is an error.
    &#34;&#34;&#34;
    if response.startswith(&#39;ERR &#39;):
        return True
    return False


def raise_for_error(response):
    &#34;&#34;&#34;Raise SonicServerError in case of error response.

    Arguments:
        response {str} -- message to check if it&#39;s error or not.

    Raises:
        SonicServerError --

    Returns:
        str -- the response message
    &#34;&#34;&#34;
    if is_error(response):
        raise SonicServerError(response)
    return response


def _parse_protocol_version(text):
    &#34;&#34;&#34;Extracts protocol version from response message

    Arguments:
        text {str} -- text that may contain protocol version info (e.g STARTED search protocol(1) buffer(20000) )

    Raises:
        ValueError -- Raised when s doesn&#39;t have protocol information

    Returns:
        str -- protocol version.
    &#34;&#34;&#34;
    matches = re.findall(&#34;protocol\((\w+)\)&#34;, text)
    if not matches:
        raise ValueError(&#34;{} doesn&#39;t contain protocol(NUMBER)&#34;.format(text))
    return matches[0]


def _parse_buffer_size(text):
    &#34;&#34;&#34;Extracts buffering from response message

    Arguments:
        text {str} -- text that may contain buffering info (e.g STARTED search protocol(1) buffer(20000) )

    Raises:
        ValueError -- Raised when s doesn&#39;t have buffering information

    Returns:
        str -- buffering.
    &#34;&#34;&#34;

    matches = re.findall(&#34;buffer\((\w+)\)&#34;, text)
    if not matches:
        raise ValueError(&#34;{} doesn&#39;t contain buffer(NUMBER)&#34;.format(text))
    return matches[0]


def _get_async_response_id(text):
    &#34;&#34;&#34;Extract async response message id.

    Arguments:
        text {str} -- text that may contain async response id (e.g PENDING gn4RLF8M )

    Raises:
        ValueError -- [description]

    Returns:
        str -- async response id
    &#34;&#34;&#34;
    text = text.strip()
    matches = re.findall(&#34;PENDING (\w+)&#34;, text)
    if not matches:
        raise ValueError(&#34;{} doesn&#39;t contain async response id&#34;.format(text))
    return matches[0]


def pythonify_result(resp):
    if resp in [&#34;OK&#34;, &#34;PONG&#34;]:
        return True

    if resp.startswith(&#34;EVENT QUERY&#34;) or resp.startswith(&#34;EVENT SUGGEST&#34;):
        return resp.split()[3:]

    if resp.startswith(&#34;RESULT&#34;):
        return int(resp.split()[-1])
    return resp


# Channels names
INGEST = &#39;ingest&#39;
SEARCH = &#39;search&#39;
CONTROL = &#39;control&#39;


class SonicClient:

    def __init__(self, host: str, port: int, password: str, channel: str):
        &#34;&#34;&#34;Base for sonic clients 

        bufsize: indicates the buffer size to be used while communicating with the server.
        protocol: sonic protocol version

        Arguments:
            host {str} -- sonic server host
            port {int} -- sonic server port
            password {str} -- user password defined in `config.cfg` file on the server side.
            channel {str} -- channel name one of (ingest, search, control)

        &#34;&#34;&#34;

        self.host = host
        self.port = port
        self._password = password
        self.channel = channel
        self.__socket = None
        self.__reader = None
        self.__writer = None
        self.bufsize = 0
        self.protocol = 1
        self.raw = False

    @property
    def address(self):
        return self.host, self.port

    @property
    def _socket(self):
        if self.__socket is not None:
            return self.__socket
        self.__socket = socket.create_connection(self.address)
        return self.__socket

    @property
    def _reader(self):
        if self.__reader is not None:
            return self.__reader
        self.__reader = self._socket.makefile(&#39;r&#39;)
        return self.__reader

    @property
    def _writer(self):
        if self.__writer is not None:
            return self.__writer
        self.__writer = self._socket.makefile(&#39;w&#39;)
        return self.__writer

    def connect(self):
        &#34;&#34;&#34;Connects to sonic server endpoint

        Returns:
            bool: True when connection happens and successfully switched to a channel.  
        &#34;&#34;&#34;
        resp = self._reader.readline()
        if &#39;CONNECTED&#39; in resp:
            self.connected = True

        resp = self._execute_command(&#34;START&#34;, self.channel, self._password)
        self.protocol = _parse_protocol_version(resp)
        self.bufsize = _parse_buffer_size(resp)

        return True

    def close(self):
        &#34;&#34;&#34;close the connection and clean up open resources.
        &#34;&#34;&#34;
        resources = (self.__reader, self.__writer, self.__socket)
        for rc in resources:
            if rc is not None:
                rc.close()
        self.__reader = None
        self.__writer = None
        self.__socket = None
        self.connected = False

    def __enter__(self):
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def _format_command(self, cmd, *args):
        &#34;&#34;&#34;Format command according to sonic protocol

        Arguments:
            cmd {str} -- a valid sonic command

        Returns:
            str -- formatted command string to be sent on the wire.
        &#34;&#34;&#34;
        cmd_str = cmd + &#34; &#34;
        cmd_str += &#34; &#34;.join(args)
        cmd_str += &#34;\n&#34;  # specs says \n, asonic does \r\n
        return cmd_str

    def _execute_command(self, cmd, *args):
        &#34;&#34;&#34;Formats and sends command with suitable arguments on the wire to sonic server

        Arguments:
            cmd {str} -- valid command

        Raises:
            ChannelError -- Raised for unsupported channel commands

        Returns:
            object|str -- depends on the `self.raw` mode
                if mode is raw: result is always a string
                else the result is converted to suitable python response (e.g boolean, int, list)
        &#34;&#34;&#34;
        if cmd not in ALL_CMDS[self.channel]:
            raise ChannelError(
                &#34;command {} isn&#39;t allowed in channel {}&#34;.format(cmd, self.channel))

        cmd_str = self._format_command(cmd, *args)
        self._writer.write(cmd_str)
        self._writer.flush()
        resp = self._get_response()

        return resp

    def _get_response(self):
        &#34;&#34;&#34;Gets a response string from sonic server.

        Returns:
            object|str -- depends on the `self.raw` mode
                if mode is raw: result is always a string
                else the result is converted to suitable python response (e.g boolean, int, list)
        &#34;&#34;&#34;

        resp = raise_for_error(self._reader.readline()).strip()
        if not self.raw:
            return pythonify_result(resp)
        return resp


class CommonCommandsMixin:
    &#34;&#34;&#34;Mixin of the commands used by all sonic channels.&#34;&#34;&#34;

    def ping(self):
        &#34;&#34;&#34;Send ping command to the server

        Returns:
            bool -- True if successfully reaching the server.
        &#34;&#34;&#34;
        return self._execute_command(&#34;PING&#34;)

    def quit(self):
        &#34;&#34;&#34;Quit the channel and closes the connection.

        &#34;&#34;&#34;
        self._execute_command(&#34;QUIT&#34;)
        self.close()

    # TODO: check help.
    def help(self, *args):
        &#34;&#34;&#34;Sends Help query.&#34;&#34;&#34;
        return self._execute_command(&#34;HELP&#34;, *args)


class IngestClient(SonicClient, CommonCommandsMixin):
    def __init__(self, host: str, port: str, password: str):
        super().__init__(host, port, password, INGEST)

    def push(self, collection: str, bucket: str, object: str, text: str, lang: str=None):
        &#34;&#34;&#34;Push search data in the index

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
            text {str} -- search text to be indexed can be a single word, or a longer text; within maximum length safety limits

        Keyword Arguments:
            lang {str} -- [description] (default: {None})

        Returns:
            bool -- True if search data are pushed in the index. 
        &#34;&#34;&#34;

        lang = &#34;LANG({})&#34;.format(lang) if lang else &#39;&#39;
        text = quote_text(text)
        return self._execute_command(&#34;PUSH&#34;, collection, bucket, object, text, lang)

    def pop(self, collection: str, bucket: str, object: str, text: str):
        &#34;&#34;&#34;Pop search data from the index

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
            text {str} -- search text to be indexed can be a single word, or a longer text; within maximum length safety limits

        Returns:
            int 
        &#34;&#34;&#34;
        text = quote_text(text)
        return self._execute_command(&#34;POP&#34;, collection, bucket, object, text)

    def count(self, collection: str, bucket: str=None, object: str=None):
        &#34;&#34;&#34;Count indexed search data

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)

        Keyword Arguments:
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)

        Returns:
            int -- count of index search data.
        &#34;&#34;&#34;
        bucket = bucket or &#39;&#39;
        object = object or &#39;&#39;
        return self._execute_command(&#39;COUNT&#39;, collection, bucket, object)

    def flush_collection(self, collection: str):
        &#34;&#34;&#34;Flush all indexed data from a collection

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)

        Returns:
            int -- number of flushed data
        &#34;&#34;&#34;
        return self._execute_command(&#39;FLUSHC&#39;, collection)

    def flush_bucket(self, collection: str, bucket: str):
        &#34;&#34;&#34;Flush all indexed data from a bucket in a collection

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)

        Returns:
            int -- number of flushed data
        &#34;&#34;&#34;
        return self._execute_command(&#39;FLUSHB&#39;, collection, bucket)

    def flush_object(self, collection: str, bucket: str, object: str):
        &#34;&#34;&#34;Flush all indexed data from an object in a bucket in collection

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)

        Returns:
            int -- number of flushed data
        &#34;&#34;&#34;
        return self._execute_command(&#39;FLUSHO&#39;, collection, bucket, object)

    def flush(self, collection: str, bucket: str=None, object: str=None):
        &#34;&#34;&#34;Flush indexed data in a collection, bucket, or in an object.

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)

        Keyword Arguments:
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)

        Returns:
            int -- number of flushed data
        &#34;&#34;&#34;
        if not bucket and not object:
            return self.flush_collection(collection)
        elif bucket and not object:
            return self.flush_bucket(collection, bucket)
        elif object and bucket:
            return self.flush_object(collection, bucket, object)


class SearchClient(SonicClient, CommonCommandsMixin):
    def __init__(self, host: str, port: int, password: str):
        &#34;&#34;&#34;Create Sonic client that operates on the Search Channel

        Arguments:
            host {str} -- valid reachable host address
            port {int} -- port number
            password {str} -- password (defined in config.cfg file on the server side)

        &#34;&#34;&#34;
        super().__init__(host, port, password, SEARCH)

    def query(self, collection: str, bucket: str, terms: str, limit: int=None, offset: int=None, lang: str=None):
        &#34;&#34;&#34;Query the database

        Arguments:
            collection {str} -- index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            terms {str} --  text for search terms

        Keyword Arguments:
            limit {int} -- a positive integer number; set within allowed maximum &amp; minimum limits
            offset {int} -- a positive integer number; set within allowed maximum &amp; minimum limits
            lang {str} -- an ISO 639-3 locale code eg. eng for English (if set, the locale must be a valid ISO 639-3 code; if not set, the locale will be guessed from text).

        Returns:
            list -- list of objects ids.
        &#34;&#34;&#34;
        limit = &#34;LIMIT({})&#34;.format(limit) if limit else &#39;&#39;
        lang = &#34;LANG({})&#34;.format(lang) if lang else &#39;&#39;
        offset = &#34;OFFSET({})&#34;.format(offset) if offset else &#39;&#39;

        terms = quote_text(terms)
        self._execute_command(
            &#39;QUERY&#39;, collection, bucket, terms, limit, offset, lang)
        resp_result = self._get_response()
        return resp_result

    def suggest(self, collection: str, bucket: str, word: str, limit: int=None):
        &#34;&#34;&#34;auto-completes word.

        Arguments:
            collection {str} -- index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            word {str} --  word to autocomplete


        Keyword Arguments:
            limit {int} -- a positive integer number; set within allowed maximum &amp; minimum limits (default: {None})

        Returns:
            list -- list of suggested words.
        &#34;&#34;&#34;
        limit = &#34;LIMIT({})&#34;.format(limit) if limit else &#39;&#39;
        word = quote_text(word)
        self._execute_command(
            &#39;SUGGEST&#39;, collection, bucket, word, limit)
        resp_result = self._get_response()
        return resp_result


class ControlClient(SonicClient, CommonCommandsMixin):
    def __init__(self, host: str, port: int, password: str):
        &#34;&#34;&#34;Create Sonic client that operates on the Control Channel

        Arguments:
            host {str} -- valid reachable host address
            port {int} -- port number
            password {str} -- password (defined in config.cfg file on the server side)

        &#34;&#34;&#34;
        super().__init__(host, port, password, CONTROL)

    def trigger(self, action: str=&#39;&#39;):
        &#34;&#34;&#34;Trigger an action

        Keyword Arguments:
            action {str} --  text for action
        &#34;&#34;&#34;
        self._execute_command(&#39;TRIGGER&#39;, action)


def test_ingest():
    with IngestClient(&#34;127.0.0.1&#34;, 1491, &#39;password&#39;) as ingestcl:
        print(ingestcl.ping())
        print(ingestcl.protocol)
        print(ingestcl.bufsize)
        ingestcl.push(&#34;wiki&#34;, &#34;articles&#34;, &#34;article-1&#34;,
                      &#34;for the love of god hell&#34;)
        ingestcl.push(&#34;wiki&#34;, &#34;articles&#34;, &#34;article-2&#34;,
                      &#34;for the love of satan heaven&#34;)
        ingestcl.push(&#34;wiki&#34;, &#34;articles&#34;, &#34;article-3&#34;,
                      &#34;for the love of lorde hello&#34;)
        ingestcl.push(&#34;wiki&#34;, &#34;articles&#34;, &#34;article-4&#34;,
                      &#34;for the god of loaf helmet&#34;)


def test_search():
    with SearchClient(&#34;127.0.0.1&#34;, 1491, &#39;password&#39;) as querycl:
        print(querycl.ping())
        print(querycl.query(&#34;wiki&#34;, &#34;articles&#34;, &#34;for&#34;))
        print(querycl.query(&#34;wiki&#34;, &#34;articles&#34;, &#34;love&#34;))
        print(querycl.suggest(&#34;wiki&#34;, &#34;articles&#34;, &#34;hell&#34;))


def test_control():
    with ControlClient(&#34;127.0.0.1&#34;, 1491, &#39;password&#39;) as controlcl:
        print(controlcl.ping())
        controlcl.trigger(&#34;consolidate&#34;)


if __name__ == &#34;__main__&#34;:
    test_ingest()
    test_search()
    test_control()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sonic.client.is_error"><code class="name flex">
<span>def <span class="ident">is_error</span></span>(<span>response)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if the response is Error or not in sonic context.</p>
<p>Errors start with <code>ERR</code></p>
<h2 id="arguments">Arguments</h2>
<p>response {str} &ndash; response string</p>
<h2 id="returns">Returns</h2>
<p>[bool] &ndash; true if response is an error.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_error(response):
    &#34;&#34;&#34;Check if the response is Error or not in sonic context.

    Errors start with `ERR`
    Arguments:
        response {str} -- response string

    Returns:
        [bool] -- true if response is an error.
    &#34;&#34;&#34;
    if response.startswith(&#39;ERR &#39;):
        return True
    return False</code></pre>
</details>
</dd>
<dt id="sonic.client.pythonify_result"><code class="name flex">
<span>def <span class="ident">pythonify_result</span></span>(<span>resp)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def pythonify_result(resp):
    if resp in [&#34;OK&#34;, &#34;PONG&#34;]:
        return True

    if resp.startswith(&#34;EVENT QUERY&#34;) or resp.startswith(&#34;EVENT SUGGEST&#34;):
        return resp.split()[3:]

    if resp.startswith(&#34;RESULT&#34;):
        return int(resp.split()[-1])
    return resp</code></pre>
</details>
</dd>
<dt id="sonic.client.quote_text"><code class="name flex">
<span>def <span class="ident">quote_text</span></span>(<span>text)</span>
</code></dt>
<dd>
<section class="desc"><p>Quote text and normalize it in sonic protocol context.</p>
<h2 id="arguments">Arguments</h2>
<p>text str &ndash; text to quote/escape</p>
<h2 id="returns">Returns</h2>
<p>str &ndash; quoted text</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def quote_text(text):
    &#34;&#34;&#34;Quote text and normalize it in sonic protocol context.

    Arguments:
        text str -- text to quote/escape

    Returns:
        str -- quoted text
    &#34;&#34;&#34;
    if text is None:
        return &#34;&#34;
    return &#39;&#34;&#39; + text.replace(&#39;&#34;&#39;, &#39;\\&#34;&#39;).replace(&#39;\r\n&#39;, &#39; &#39;) + &#39;&#34;&#39;</code></pre>
</details>
</dd>
<dt id="sonic.client.raise_for_error"><code class="name flex">
<span>def <span class="ident">raise_for_error</span></span>(<span>response)</span>
</code></dt>
<dd>
<section class="desc"><p>Raise SonicServerError in case of error response.</p>
<h2 id="arguments">Arguments</h2>
<p>response {str} &ndash; message to check if it's error or not.</p>
<h2 id="raises">Raises</h2>
<p>SonicServerError &ndash;</p>
<h2 id="returns">Returns</h2>
<p>str &ndash; the response message</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def raise_for_error(response):
    &#34;&#34;&#34;Raise SonicServerError in case of error response.

    Arguments:
        response {str} -- message to check if it&#39;s error or not.

    Raises:
        SonicServerError --

    Returns:
        str -- the response message
    &#34;&#34;&#34;
    if is_error(response):
        raise SonicServerError(response)
    return response</code></pre>
</details>
</dd>
<dt id="sonic.client.test_control"><code class="name flex">
<span>def <span class="ident">test_control</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def test_control():
    with ControlClient(&#34;127.0.0.1&#34;, 1491, &#39;password&#39;) as controlcl:
        print(controlcl.ping())
        controlcl.trigger(&#34;consolidate&#34;)</code></pre>
</details>
</dd>
<dt id="sonic.client.test_ingest"><code class="name flex">
<span>def <span class="ident">test_ingest</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def test_ingest():
    with IngestClient(&#34;127.0.0.1&#34;, 1491, &#39;password&#39;) as ingestcl:
        print(ingestcl.ping())
        print(ingestcl.protocol)
        print(ingestcl.bufsize)
        ingestcl.push(&#34;wiki&#34;, &#34;articles&#34;, &#34;article-1&#34;,
                      &#34;for the love of god hell&#34;)
        ingestcl.push(&#34;wiki&#34;, &#34;articles&#34;, &#34;article-2&#34;,
                      &#34;for the love of satan heaven&#34;)
        ingestcl.push(&#34;wiki&#34;, &#34;articles&#34;, &#34;article-3&#34;,
                      &#34;for the love of lorde hello&#34;)
        ingestcl.push(&#34;wiki&#34;, &#34;articles&#34;, &#34;article-4&#34;,
                      &#34;for the god of loaf helmet&#34;)</code></pre>
</details>
</dd>
<dt id="sonic.client.test_search"><code class="name flex">
<span>def <span class="ident">test_search</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def test_search():
    with SearchClient(&#34;127.0.0.1&#34;, 1491, &#39;password&#39;) as querycl:
        print(querycl.ping())
        print(querycl.query(&#34;wiki&#34;, &#34;articles&#34;, &#34;for&#34;))
        print(querycl.query(&#34;wiki&#34;, &#34;articles&#34;, &#34;love&#34;))
        print(querycl.suggest(&#34;wiki&#34;, &#34;articles&#34;, &#34;hell&#34;))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sonic.client.ChannelError"><code class="flex name class">
<span>class <span class="ident">ChannelError</span></span>
<span>(</span><span><small>ancestors:</small> builtins.Exception, builtins.BaseException)</span>
</code></dt>
<dd>
<section class="desc"><p>Sonic Channel specific exception</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ChannelError(Exception):
    &#34;&#34;&#34;Sonic Channel specific exception&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="sonic.client.CommonCommandsMixin"><code class="flex name class">
<span>class <span class="ident">CommonCommandsMixin</span></span>
</code></dt>
<dd>
<section class="desc"><p>Mixin of the commands used by all sonic channels.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CommonCommandsMixin:
    &#34;&#34;&#34;Mixin of the commands used by all sonic channels.&#34;&#34;&#34;

    def ping(self):
        &#34;&#34;&#34;Send ping command to the server

        Returns:
            bool -- True if successfully reaching the server.
        &#34;&#34;&#34;
        return self._execute_command(&#34;PING&#34;)

    def quit(self):
        &#34;&#34;&#34;Quit the channel and closes the connection.

        &#34;&#34;&#34;
        self._execute_command(&#34;QUIT&#34;)
        self.close()

    # TODO: check help.
    def help(self, *args):
        &#34;&#34;&#34;Sends Help query.&#34;&#34;&#34;
        return self._execute_command(&#34;HELP&#34;, *args)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sonic.client.IngestClient" href="#sonic.client.IngestClient">IngestClient</a></li>
<li><a title="sonic.client.SearchClient" href="#sonic.client.SearchClient">SearchClient</a></li>
<li><a title="sonic.client.ControlClient" href="#sonic.client.ControlClient">ControlClient</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sonic.client.CommonCommandsMixin.help"><code class="name flex">
<span>def <span class="ident">help</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<section class="desc"><p>Sends Help query.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def help(self, *args):
    &#34;&#34;&#34;Sends Help query.&#34;&#34;&#34;
    return self._execute_command(&#34;HELP&#34;, *args)</code></pre>
</details>
</dd>
<dt id="sonic.client.CommonCommandsMixin.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Send ping command to the server</p>
<h2 id="returns">Returns</h2>
<p>bool &ndash; True if successfully reaching the server.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ping(self):
    &#34;&#34;&#34;Send ping command to the server

    Returns:
        bool -- True if successfully reaching the server.
    &#34;&#34;&#34;
    return self._execute_command(&#34;PING&#34;)</code></pre>
</details>
</dd>
<dt id="sonic.client.CommonCommandsMixin.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Quit the channel and closes the connection.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def quit(self):
    &#34;&#34;&#34;Quit the channel and closes the connection.

    &#34;&#34;&#34;
    self._execute_command(&#34;QUIT&#34;)
    self.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sonic.client.ControlClient"><code class="flex name class">
<span>class <span class="ident">ControlClient</span></span>
<span>(</span><span><small>ancestors:</small> <a title="sonic.client.SonicClient" href="#sonic.client.SonicClient">SonicClient</a>, <a title="sonic.client.CommonCommandsMixin" href="#sonic.client.CommonCommandsMixin">CommonCommandsMixin</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>Mixin of the commands used by all sonic channels.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ControlClient(SonicClient, CommonCommandsMixin):
    def __init__(self, host: str, port: int, password: str):
        &#34;&#34;&#34;Create Sonic client that operates on the Control Channel

        Arguments:
            host {str} -- valid reachable host address
            port {int} -- port number
            password {str} -- password (defined in config.cfg file on the server side)

        &#34;&#34;&#34;
        super().__init__(host, port, password, CONTROL)

    def trigger(self, action: str=&#39;&#39;):
        &#34;&#34;&#34;Trigger an action

        Keyword Arguments:
            action {str} --  text for action
        &#34;&#34;&#34;
        self._execute_command(&#39;TRIGGER&#39;, action)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="sonic.client.ControlClient.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, host, port, password)</span>
</code></dt>
<dd>
<section class="desc"><p>Create Sonic client that operates on the Control Channel</p>
<h2 id="arguments">Arguments</h2>
<p>host {str} &ndash; valid reachable host address
port {int} &ndash; port number
password {str} &ndash; password (defined in config.cfg file on the server side)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, host: str, port: int, password: str):
    &#34;&#34;&#34;Create Sonic client that operates on the Control Channel

    Arguments:
        host {str} -- valid reachable host address
        port {int} -- port number
        password {str} -- password (defined in config.cfg file on the server side)

    &#34;&#34;&#34;
    super().__init__(host, port, password, CONTROL)</code></pre>
</details>
</dd>
<dt id="sonic.client.ControlClient.trigger"><code class="name flex">
<span>def <span class="ident">trigger</span></span>(<span>self, action=&#39;&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Trigger an action</p>
<p>Keyword Arguments:
action {str} &ndash;
text for action</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def trigger(self, action: str=&#39;&#39;):
    &#34;&#34;&#34;Trigger an action

    Keyword Arguments:
        action {str} --  text for action
    &#34;&#34;&#34;
    self._execute_command(&#39;TRIGGER&#39;, action)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sonic.client.SonicClient" href="#sonic.client.SonicClient">SonicClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sonic.client.SonicClient.close" href="#sonic.client.SonicClient.close">close</a></code></li>
<li><code><a title="sonic.client.SonicClient.connect" href="#sonic.client.SonicClient.connect">connect</a></code></li>
</ul>
</li>
<li><code><b><a title="sonic.client.CommonCommandsMixin" href="#sonic.client.CommonCommandsMixin">CommonCommandsMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="sonic.client.CommonCommandsMixin.help" href="#sonic.client.CommonCommandsMixin.help">help</a></code></li>
<li><code><a title="sonic.client.CommonCommandsMixin.ping" href="#sonic.client.CommonCommandsMixin.ping">ping</a></code></li>
<li><code><a title="sonic.client.CommonCommandsMixin.quit" href="#sonic.client.CommonCommandsMixin.quit">quit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sonic.client.IngestClient"><code class="flex name class">
<span>class <span class="ident">IngestClient</span></span>
<span>(</span><span><small>ancestors:</small> <a title="sonic.client.SonicClient" href="#sonic.client.SonicClient">SonicClient</a>, <a title="sonic.client.CommonCommandsMixin" href="#sonic.client.CommonCommandsMixin">CommonCommandsMixin</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>Mixin of the commands used by all sonic channels.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class IngestClient(SonicClient, CommonCommandsMixin):
    def __init__(self, host: str, port: str, password: str):
        super().__init__(host, port, password, INGEST)

    def push(self, collection: str, bucket: str, object: str, text: str, lang: str=None):
        &#34;&#34;&#34;Push search data in the index

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
            text {str} -- search text to be indexed can be a single word, or a longer text; within maximum length safety limits

        Keyword Arguments:
            lang {str} -- [description] (default: {None})

        Returns:
            bool -- True if search data are pushed in the index. 
        &#34;&#34;&#34;

        lang = &#34;LANG({})&#34;.format(lang) if lang else &#39;&#39;
        text = quote_text(text)
        return self._execute_command(&#34;PUSH&#34;, collection, bucket, object, text, lang)

    def pop(self, collection: str, bucket: str, object: str, text: str):
        &#34;&#34;&#34;Pop search data from the index

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
            text {str} -- search text to be indexed can be a single word, or a longer text; within maximum length safety limits

        Returns:
            int 
        &#34;&#34;&#34;
        text = quote_text(text)
        return self._execute_command(&#34;POP&#34;, collection, bucket, object, text)

    def count(self, collection: str, bucket: str=None, object: str=None):
        &#34;&#34;&#34;Count indexed search data

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)

        Keyword Arguments:
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)

        Returns:
            int -- count of index search data.
        &#34;&#34;&#34;
        bucket = bucket or &#39;&#39;
        object = object or &#39;&#39;
        return self._execute_command(&#39;COUNT&#39;, collection, bucket, object)

    def flush_collection(self, collection: str):
        &#34;&#34;&#34;Flush all indexed data from a collection

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)

        Returns:
            int -- number of flushed data
        &#34;&#34;&#34;
        return self._execute_command(&#39;FLUSHC&#39;, collection)

    def flush_bucket(self, collection: str, bucket: str):
        &#34;&#34;&#34;Flush all indexed data from a bucket in a collection

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)

        Returns:
            int -- number of flushed data
        &#34;&#34;&#34;
        return self._execute_command(&#39;FLUSHB&#39;, collection, bucket)

    def flush_object(self, collection: str, bucket: str, object: str):
        &#34;&#34;&#34;Flush all indexed data from an object in a bucket in collection

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)

        Returns:
            int -- number of flushed data
        &#34;&#34;&#34;
        return self._execute_command(&#39;FLUSHO&#39;, collection, bucket, object)

    def flush(self, collection: str, bucket: str=None, object: str=None):
        &#34;&#34;&#34;Flush indexed data in a collection, bucket, or in an object.

        Arguments:
            collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)

        Keyword Arguments:
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)

        Returns:
            int -- number of flushed data
        &#34;&#34;&#34;
        if not bucket and not object:
            return self.flush_collection(collection)
        elif bucket and not object:
            return self.flush_bucket(collection, bucket)
        elif object and bucket:
            return self.flush_object(collection, bucket, object)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="sonic.client.IngestClient.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self, collection, bucket=None, object=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Count indexed search data</p>
<h2 id="arguments">Arguments</h2>
<p>collection {str} &ndash;
index collection (ie. what you search in, eg. messages, products, etc.)
Keyword Arguments:
bucket {str} &ndash; index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
object {str} &ndash;
object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)</p>
<h2 id="returns">Returns</h2>
<p>int &ndash; count of index search data.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def count(self, collection: str, bucket: str=None, object: str=None):
    &#34;&#34;&#34;Count indexed search data

    Arguments:
        collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)

    Keyword Arguments:
        bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
        object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)

    Returns:
        int -- count of index search data.
    &#34;&#34;&#34;
    bucket = bucket or &#39;&#39;
    object = object or &#39;&#39;
    return self._execute_command(&#39;COUNT&#39;, collection, bucket, object)</code></pre>
</details>
</dd>
<dt id="sonic.client.IngestClient.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self, collection, bucket=None, object=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Flush indexed data in a collection, bucket, or in an object.</p>
<h2 id="arguments">Arguments</h2>
<p>collection {str} &ndash;
index collection (ie. what you search in, eg. messages, products, etc.)
Keyword Arguments:
bucket {str} &ndash; index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
object {str} &ndash;
object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)</p>
<h2 id="returns">Returns</h2>
<p>int &ndash; number of flushed data</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def flush(self, collection: str, bucket: str=None, object: str=None):
    &#34;&#34;&#34;Flush indexed data in a collection, bucket, or in an object.

    Arguments:
        collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)

    Keyword Arguments:
        bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
        object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)

    Returns:
        int -- number of flushed data
    &#34;&#34;&#34;
    if not bucket and not object:
        return self.flush_collection(collection)
    elif bucket and not object:
        return self.flush_bucket(collection, bucket)
    elif object and bucket:
        return self.flush_object(collection, bucket, object)</code></pre>
</details>
</dd>
<dt id="sonic.client.IngestClient.flush_bucket"><code class="name flex">
<span>def <span class="ident">flush_bucket</span></span>(<span>self, collection, bucket)</span>
</code></dt>
<dd>
<section class="desc"><p>Flush all indexed data from a bucket in a collection</p>
<h2 id="arguments">Arguments</h2>
<p>collection {str} &ndash;
index collection (ie. what you search in, eg. messages, products, etc.)
bucket {str} &ndash; index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)</p>
<h2 id="returns">Returns</h2>
<p>int &ndash; number of flushed data</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def flush_bucket(self, collection: str, bucket: str):
    &#34;&#34;&#34;Flush all indexed data from a bucket in a collection

    Arguments:
        collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
        bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)

    Returns:
        int -- number of flushed data
    &#34;&#34;&#34;
    return self._execute_command(&#39;FLUSHB&#39;, collection, bucket)</code></pre>
</details>
</dd>
<dt id="sonic.client.IngestClient.flush_collection"><code class="name flex">
<span>def <span class="ident">flush_collection</span></span>(<span>self, collection)</span>
</code></dt>
<dd>
<section class="desc"><p>Flush all indexed data from a collection</p>
<h2 id="arguments">Arguments</h2>
<p>collection {str} &ndash;
index collection (ie. what you search in, eg. messages, products, etc.)</p>
<h2 id="returns">Returns</h2>
<p>int &ndash; number of flushed data</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def flush_collection(self, collection: str):
    &#34;&#34;&#34;Flush all indexed data from a collection

    Arguments:
        collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)

    Returns:
        int -- number of flushed data
    &#34;&#34;&#34;
    return self._execute_command(&#39;FLUSHC&#39;, collection)</code></pre>
</details>
</dd>
<dt id="sonic.client.IngestClient.flush_object"><code class="name flex">
<span>def <span class="ident">flush_object</span></span>(<span>self, collection, bucket, object)</span>
</code></dt>
<dd>
<section class="desc"><p>Flush all indexed data from an object in a bucket in collection</p>
<h2 id="arguments">Arguments</h2>
<p>collection {str} &ndash;
index collection (ie. what you search in, eg. messages, products, etc.)
bucket {str} &ndash; index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
object {str} &ndash;
object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)</p>
<h2 id="returns">Returns</h2>
<p>int &ndash; number of flushed data</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def flush_object(self, collection: str, bucket: str, object: str):
    &#34;&#34;&#34;Flush all indexed data from an object in a bucket in collection

    Arguments:
        collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
        bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
        object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)

    Returns:
        int -- number of flushed data
    &#34;&#34;&#34;
    return self._execute_command(&#39;FLUSHO&#39;, collection, bucket, object)</code></pre>
</details>
</dd>
<dt id="sonic.client.IngestClient.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, collection, bucket, object, text)</span>
</code></dt>
<dd>
<section class="desc"><p>Pop search data from the index</p>
<h2 id="arguments">Arguments</h2>
<p>collection {str} &ndash;
index collection (ie. what you search in, eg. messages, products, etc.)
bucket {str} &ndash; index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
object {str} &ndash;
object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
text {str} &ndash; search text to be indexed can be a single word, or a longer text; within maximum length safety limits</p>
<h2 id="returns">Returns</h2>
<p>int</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def pop(self, collection: str, bucket: str, object: str, text: str):
    &#34;&#34;&#34;Pop search data from the index

    Arguments:
        collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
        bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
        object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
        text {str} -- search text to be indexed can be a single word, or a longer text; within maximum length safety limits

    Returns:
        int 
    &#34;&#34;&#34;
    text = quote_text(text)
    return self._execute_command(&#34;POP&#34;, collection, bucket, object, text)</code></pre>
</details>
</dd>
<dt id="sonic.client.IngestClient.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, collection, bucket, object, text, lang=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Push search data in the index</p>
<h2 id="arguments">Arguments</h2>
<p>collection {str} &ndash;
index collection (ie. what you search in, eg. messages, products, etc.)
bucket {str} &ndash; index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
object {str} &ndash;
object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
text {str} &ndash; search text to be indexed can be a single word, or a longer text; within maximum length safety limits
Keyword Arguments:
lang {str} &ndash; [description] (default: {None})</p>
<h2 id="returns">Returns</h2>
<p>bool &ndash; True if search data are pushed in the index.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def push(self, collection: str, bucket: str, object: str, text: str, lang: str=None):
    &#34;&#34;&#34;Push search data in the index

    Arguments:
        collection {str} --  index collection (ie. what you search in, eg. messages, products, etc.)
        bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
        object {str} --  object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
        text {str} -- search text to be indexed can be a single word, or a longer text; within maximum length safety limits

    Keyword Arguments:
        lang {str} -- [description] (default: {None})

    Returns:
        bool -- True if search data are pushed in the index. 
    &#34;&#34;&#34;

    lang = &#34;LANG({})&#34;.format(lang) if lang else &#39;&#39;
    text = quote_text(text)
    return self._execute_command(&#34;PUSH&#34;, collection, bucket, object, text, lang)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sonic.client.SonicClient" href="#sonic.client.SonicClient">SonicClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sonic.client.SonicClient.__init__" href="#sonic.client.SonicClient.__init__">__init__</a></code></li>
<li><code><a title="sonic.client.SonicClient.close" href="#sonic.client.SonicClient.close">close</a></code></li>
<li><code><a title="sonic.client.SonicClient.connect" href="#sonic.client.SonicClient.connect">connect</a></code></li>
</ul>
</li>
<li><code><b><a title="sonic.client.CommonCommandsMixin" href="#sonic.client.CommonCommandsMixin">CommonCommandsMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="sonic.client.CommonCommandsMixin.help" href="#sonic.client.CommonCommandsMixin.help">help</a></code></li>
<li><code><a title="sonic.client.CommonCommandsMixin.ping" href="#sonic.client.CommonCommandsMixin.ping">ping</a></code></li>
<li><code><a title="sonic.client.CommonCommandsMixin.quit" href="#sonic.client.CommonCommandsMixin.quit">quit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sonic.client.SearchClient"><code class="flex name class">
<span>class <span class="ident">SearchClient</span></span>
<span>(</span><span><small>ancestors:</small> <a title="sonic.client.SonicClient" href="#sonic.client.SonicClient">SonicClient</a>, <a title="sonic.client.CommonCommandsMixin" href="#sonic.client.CommonCommandsMixin">CommonCommandsMixin</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>Mixin of the commands used by all sonic channels.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class SearchClient(SonicClient, CommonCommandsMixin):
    def __init__(self, host: str, port: int, password: str):
        &#34;&#34;&#34;Create Sonic client that operates on the Search Channel

        Arguments:
            host {str} -- valid reachable host address
            port {int} -- port number
            password {str} -- password (defined in config.cfg file on the server side)

        &#34;&#34;&#34;
        super().__init__(host, port, password, SEARCH)

    def query(self, collection: str, bucket: str, terms: str, limit: int=None, offset: int=None, lang: str=None):
        &#34;&#34;&#34;Query the database

        Arguments:
            collection {str} -- index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            terms {str} --  text for search terms

        Keyword Arguments:
            limit {int} -- a positive integer number; set within allowed maximum &amp; minimum limits
            offset {int} -- a positive integer number; set within allowed maximum &amp; minimum limits
            lang {str} -- an ISO 639-3 locale code eg. eng for English (if set, the locale must be a valid ISO 639-3 code; if not set, the locale will be guessed from text).

        Returns:
            list -- list of objects ids.
        &#34;&#34;&#34;
        limit = &#34;LIMIT({})&#34;.format(limit) if limit else &#39;&#39;
        lang = &#34;LANG({})&#34;.format(lang) if lang else &#39;&#39;
        offset = &#34;OFFSET({})&#34;.format(offset) if offset else &#39;&#39;

        terms = quote_text(terms)
        self._execute_command(
            &#39;QUERY&#39;, collection, bucket, terms, limit, offset, lang)
        resp_result = self._get_response()
        return resp_result

    def suggest(self, collection: str, bucket: str, word: str, limit: int=None):
        &#34;&#34;&#34;auto-completes word.

        Arguments:
            collection {str} -- index collection (ie. what you search in, eg. messages, products, etc.)
            bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
            word {str} --  word to autocomplete


        Keyword Arguments:
            limit {int} -- a positive integer number; set within allowed maximum &amp; minimum limits (default: {None})

        Returns:
            list -- list of suggested words.
        &#34;&#34;&#34;
        limit = &#34;LIMIT({})&#34;.format(limit) if limit else &#39;&#39;
        word = quote_text(word)
        self._execute_command(
            &#39;SUGGEST&#39;, collection, bucket, word, limit)
        resp_result = self._get_response()
        return resp_result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="sonic.client.SearchClient.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, host, port, password)</span>
</code></dt>
<dd>
<section class="desc"><p>Create Sonic client that operates on the Search Channel</p>
<h2 id="arguments">Arguments</h2>
<p>host {str} &ndash; valid reachable host address
port {int} &ndash; port number
password {str} &ndash; password (defined in config.cfg file on the server side)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, host: str, port: int, password: str):
    &#34;&#34;&#34;Create Sonic client that operates on the Search Channel

    Arguments:
        host {str} -- valid reachable host address
        port {int} -- port number
        password {str} -- password (defined in config.cfg file on the server side)

    &#34;&#34;&#34;
    super().__init__(host, port, password, SEARCH)</code></pre>
</details>
</dd>
<dt id="sonic.client.SearchClient.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self, collection, bucket, terms, limit=None, offset=None, lang=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Query the database</p>
<h2 id="arguments">Arguments</h2>
<p>collection {str} &ndash; index collection (ie. what you search in, eg. messages, products, etc.)
bucket {str} &ndash; index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
terms {str} &ndash;
text for search terms
Keyword Arguments:
limit {int} &ndash; a positive integer number; set within allowed maximum &amp; minimum limits
offset {int} &ndash; a positive integer number; set within allowed maximum &amp; minimum limits
lang {str} &ndash; an ISO 639-3 locale code eg. eng for English (if set, the locale must be a valid ISO 639-3 code; if not set, the locale will be guessed from text).</p>
<h2 id="returns">Returns</h2>
<p>list &ndash; list of objects ids.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def query(self, collection: str, bucket: str, terms: str, limit: int=None, offset: int=None, lang: str=None):
    &#34;&#34;&#34;Query the database

    Arguments:
        collection {str} -- index collection (ie. what you search in, eg. messages, products, etc.)
        bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
        terms {str} --  text for search terms

    Keyword Arguments:
        limit {int} -- a positive integer number; set within allowed maximum &amp; minimum limits
        offset {int} -- a positive integer number; set within allowed maximum &amp; minimum limits
        lang {str} -- an ISO 639-3 locale code eg. eng for English (if set, the locale must be a valid ISO 639-3 code; if not set, the locale will be guessed from text).

    Returns:
        list -- list of objects ids.
    &#34;&#34;&#34;
    limit = &#34;LIMIT({})&#34;.format(limit) if limit else &#39;&#39;
    lang = &#34;LANG({})&#34;.format(lang) if lang else &#39;&#39;
    offset = &#34;OFFSET({})&#34;.format(offset) if offset else &#39;&#39;

    terms = quote_text(terms)
    self._execute_command(
        &#39;QUERY&#39;, collection, bucket, terms, limit, offset, lang)
    resp_result = self._get_response()
    return resp_result</code></pre>
</details>
</dd>
<dt id="sonic.client.SearchClient.suggest"><code class="name flex">
<span>def <span class="ident">suggest</span></span>(<span>self, collection, bucket, word, limit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>auto-completes word.</p>
<h2 id="arguments">Arguments</h2>
<p>collection {str} &ndash; index collection (ie. what you search in, eg. messages, products, etc.)
bucket {str} &ndash; index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
word {str} &ndash;
word to autocomplete
Keyword Arguments:
limit {int} &ndash; a positive integer number; set within allowed maximum &amp; minimum limits (default: {None})</p>
<h2 id="returns">Returns</h2>
<p>list &ndash; list of suggested words.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def suggest(self, collection: str, bucket: str, word: str, limit: int=None):
    &#34;&#34;&#34;auto-completes word.

    Arguments:
        collection {str} -- index collection (ie. what you search in, eg. messages, products, etc.)
        bucket {str} -- index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, default, common, ..)
        word {str} --  word to autocomplete


    Keyword Arguments:
        limit {int} -- a positive integer number; set within allowed maximum &amp; minimum limits (default: {None})

    Returns:
        list -- list of suggested words.
    &#34;&#34;&#34;
    limit = &#34;LIMIT({})&#34;.format(limit) if limit else &#39;&#39;
    word = quote_text(word)
    self._execute_command(
        &#39;SUGGEST&#39;, collection, bucket, word, limit)
    resp_result = self._get_response()
    return resp_result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sonic.client.SonicClient" href="#sonic.client.SonicClient">SonicClient</a></b></code>:
<ul class="hlist">
<li><code><a title="sonic.client.SonicClient.close" href="#sonic.client.SonicClient.close">close</a></code></li>
<li><code><a title="sonic.client.SonicClient.connect" href="#sonic.client.SonicClient.connect">connect</a></code></li>
</ul>
</li>
<li><code><b><a title="sonic.client.CommonCommandsMixin" href="#sonic.client.CommonCommandsMixin">CommonCommandsMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="sonic.client.CommonCommandsMixin.help" href="#sonic.client.CommonCommandsMixin.help">help</a></code></li>
<li><code><a title="sonic.client.CommonCommandsMixin.ping" href="#sonic.client.CommonCommandsMixin.ping">ping</a></code></li>
<li><code><a title="sonic.client.CommonCommandsMixin.quit" href="#sonic.client.CommonCommandsMixin.quit">quit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sonic.client.SonicClient"><code class="flex name class">
<span>class <span class="ident">SonicClient</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class SonicClient:

    def __init__(self, host: str, port: int, password: str, channel: str):
        &#34;&#34;&#34;Base for sonic clients 

        bufsize: indicates the buffer size to be used while communicating with the server.
        protocol: sonic protocol version

        Arguments:
            host {str} -- sonic server host
            port {int} -- sonic server port
            password {str} -- user password defined in `config.cfg` file on the server side.
            channel {str} -- channel name one of (ingest, search, control)

        &#34;&#34;&#34;

        self.host = host
        self.port = port
        self._password = password
        self.channel = channel
        self.__socket = None
        self.__reader = None
        self.__writer = None
        self.bufsize = 0
        self.protocol = 1
        self.raw = False

    @property
    def address(self):
        return self.host, self.port

    @property
    def _socket(self):
        if self.__socket is not None:
            return self.__socket
        self.__socket = socket.create_connection(self.address)
        return self.__socket

    @property
    def _reader(self):
        if self.__reader is not None:
            return self.__reader
        self.__reader = self._socket.makefile(&#39;r&#39;)
        return self.__reader

    @property
    def _writer(self):
        if self.__writer is not None:
            return self.__writer
        self.__writer = self._socket.makefile(&#39;w&#39;)
        return self.__writer

    def connect(self):
        &#34;&#34;&#34;Connects to sonic server endpoint

        Returns:
            bool: True when connection happens and successfully switched to a channel.  
        &#34;&#34;&#34;
        resp = self._reader.readline()
        if &#39;CONNECTED&#39; in resp:
            self.connected = True

        resp = self._execute_command(&#34;START&#34;, self.channel, self._password)
        self.protocol = _parse_protocol_version(resp)
        self.bufsize = _parse_buffer_size(resp)

        return True

    def close(self):
        &#34;&#34;&#34;close the connection and clean up open resources.
        &#34;&#34;&#34;
        resources = (self.__reader, self.__writer, self.__socket)
        for rc in resources:
            if rc is not None:
                rc.close()
        self.__reader = None
        self.__writer = None
        self.__socket = None
        self.connected = False

    def __enter__(self):
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def _format_command(self, cmd, *args):
        &#34;&#34;&#34;Format command according to sonic protocol

        Arguments:
            cmd {str} -- a valid sonic command

        Returns:
            str -- formatted command string to be sent on the wire.
        &#34;&#34;&#34;
        cmd_str = cmd + &#34; &#34;
        cmd_str += &#34; &#34;.join(args)
        cmd_str += &#34;\n&#34;  # specs says \n, asonic does \r\n
        return cmd_str

    def _execute_command(self, cmd, *args):
        &#34;&#34;&#34;Formats and sends command with suitable arguments on the wire to sonic server

        Arguments:
            cmd {str} -- valid command

        Raises:
            ChannelError -- Raised for unsupported channel commands

        Returns:
            object|str -- depends on the `self.raw` mode
                if mode is raw: result is always a string
                else the result is converted to suitable python response (e.g boolean, int, list)
        &#34;&#34;&#34;
        if cmd not in ALL_CMDS[self.channel]:
            raise ChannelError(
                &#34;command {} isn&#39;t allowed in channel {}&#34;.format(cmd, self.channel))

        cmd_str = self._format_command(cmd, *args)
        self._writer.write(cmd_str)
        self._writer.flush()
        resp = self._get_response()

        return resp

    def _get_response(self):
        &#34;&#34;&#34;Gets a response string from sonic server.

        Returns:
            object|str -- depends on the `self.raw` mode
                if mode is raw: result is always a string
                else the result is converted to suitable python response (e.g boolean, int, list)
        &#34;&#34;&#34;

        resp = raise_for_error(self._reader.readline()).strip()
        if not self.raw:
            return pythonify_result(resp)
        return resp</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sonic.client.IngestClient" href="#sonic.client.IngestClient">IngestClient</a></li>
<li><a title="sonic.client.SearchClient" href="#sonic.client.SearchClient">SearchClient</a></li>
<li><a title="sonic.client.ControlClient" href="#sonic.client.ControlClient">ControlClient</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="sonic.client.SonicClient.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def address(self):
    return self.host, self.port</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sonic.client.SonicClient.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, host, port, password, channel)</span>
</code></dt>
<dd>
<section class="desc"><p>Base for sonic clients </p>
<dl>
<dt>bufsize: indicates the buffer size to be used while communicating with the server.</dt>
<dt><strong><code>protocol</code></strong> :&ensp;<a title="sonic" href="index.html"><code>sonic</code></a> <code>protocol</code> <code>version</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="arguments">Arguments</h2>
<p>host {str} &ndash; sonic server host
port {int} &ndash; sonic server port
password {str} &ndash; user password defined in <code>config.cfg</code> file on the server side.
channel {str} &ndash; channel name one of (ingest, search, control)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, host: str, port: int, password: str, channel: str):
    &#34;&#34;&#34;Base for sonic clients 

    bufsize: indicates the buffer size to be used while communicating with the server.
    protocol: sonic protocol version

    Arguments:
        host {str} -- sonic server host
        port {int} -- sonic server port
        password {str} -- user password defined in `config.cfg` file on the server side.
        channel {str} -- channel name one of (ingest, search, control)

    &#34;&#34;&#34;

    self.host = host
    self.port = port
    self._password = password
    self.channel = channel
    self.__socket = None
    self.__reader = None
    self.__writer = None
    self.bufsize = 0
    self.protocol = 1
    self.raw = False</code></pre>
</details>
</dd>
<dt id="sonic.client.SonicClient.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>close the connection and clean up open resources.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;close the connection and clean up open resources.
    &#34;&#34;&#34;
    resources = (self.__reader, self.__writer, self.__socket)
    for rc in resources:
        if rc is not None:
            rc.close()
    self.__reader = None
    self.__writer = None
    self.__socket = None
    self.connected = False</code></pre>
</details>
</dd>
<dt id="sonic.client.SonicClient.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Connects to sonic server endpoint</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>True when connection happens and successfully switched to a channel.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;Connects to sonic server endpoint

    Returns:
        bool: True when connection happens and successfully switched to a channel.  
    &#34;&#34;&#34;
    resp = self._reader.readline()
    if &#39;CONNECTED&#39; in resp:
        self.connected = True

    resp = self._execute_command(&#34;START&#34;, self.channel, self._password)
    self.protocol = _parse_protocol_version(resp)
    self.bufsize = _parse_buffer_size(resp)

    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sonic.client.SonicServerError"><code class="flex name class">
<span>class <span class="ident">SonicServerError</span></span>
<span>(</span><span><small>ancestors:</small> builtins.Exception, builtins.BaseException)</span>
</code></dt>
<dd>
<section class="desc"><p>Generic Sonic Server exception</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class SonicServerError(Exception):
    &#34;&#34;&#34;Generic Sonic Server exception&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sonic" href="index.html">sonic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="sonic.client.is_error" href="#sonic.client.is_error">is_error</a></code></li>
<li><code><a title="sonic.client.pythonify_result" href="#sonic.client.pythonify_result">pythonify_result</a></code></li>
<li><code><a title="sonic.client.quote_text" href="#sonic.client.quote_text">quote_text</a></code></li>
<li><code><a title="sonic.client.raise_for_error" href="#sonic.client.raise_for_error">raise_for_error</a></code></li>
<li><code><a title="sonic.client.test_control" href="#sonic.client.test_control">test_control</a></code></li>
<li><code><a title="sonic.client.test_ingest" href="#sonic.client.test_ingest">test_ingest</a></code></li>
<li><code><a title="sonic.client.test_search" href="#sonic.client.test_search">test_search</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sonic.client.ChannelError" href="#sonic.client.ChannelError">ChannelError</a></code></h4>
</li>
<li>
<h4><code><a title="sonic.client.CommonCommandsMixin" href="#sonic.client.CommonCommandsMixin">CommonCommandsMixin</a></code></h4>
<ul class="">
<li><code><a title="sonic.client.CommonCommandsMixin.help" href="#sonic.client.CommonCommandsMixin.help">help</a></code></li>
<li><code><a title="sonic.client.CommonCommandsMixin.ping" href="#sonic.client.CommonCommandsMixin.ping">ping</a></code></li>
<li><code><a title="sonic.client.CommonCommandsMixin.quit" href="#sonic.client.CommonCommandsMixin.quit">quit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sonic.client.ControlClient" href="#sonic.client.ControlClient">ControlClient</a></code></h4>
<ul class="">
<li><code><a title="sonic.client.ControlClient.__init__" href="#sonic.client.ControlClient.__init__">__init__</a></code></li>
<li><code><a title="sonic.client.ControlClient.trigger" href="#sonic.client.ControlClient.trigger">trigger</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sonic.client.IngestClient" href="#sonic.client.IngestClient">IngestClient</a></code></h4>
<ul class="two-column">
<li><code><a title="sonic.client.IngestClient.count" href="#sonic.client.IngestClient.count">count</a></code></li>
<li><code><a title="sonic.client.IngestClient.flush" href="#sonic.client.IngestClient.flush">flush</a></code></li>
<li><code><a title="sonic.client.IngestClient.flush_bucket" href="#sonic.client.IngestClient.flush_bucket">flush_bucket</a></code></li>
<li><code><a title="sonic.client.IngestClient.flush_collection" href="#sonic.client.IngestClient.flush_collection">flush_collection</a></code></li>
<li><code><a title="sonic.client.IngestClient.flush_object" href="#sonic.client.IngestClient.flush_object">flush_object</a></code></li>
<li><code><a title="sonic.client.IngestClient.pop" href="#sonic.client.IngestClient.pop">pop</a></code></li>
<li><code><a title="sonic.client.IngestClient.push" href="#sonic.client.IngestClient.push">push</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sonic.client.SearchClient" href="#sonic.client.SearchClient">SearchClient</a></code></h4>
<ul class="">
<li><code><a title="sonic.client.SearchClient.__init__" href="#sonic.client.SearchClient.__init__">__init__</a></code></li>
<li><code><a title="sonic.client.SearchClient.query" href="#sonic.client.SearchClient.query">query</a></code></li>
<li><code><a title="sonic.client.SearchClient.suggest" href="#sonic.client.SearchClient.suggest">suggest</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sonic.client.SonicClient" href="#sonic.client.SonicClient">SonicClient</a></code></h4>
<ul class="">
<li><code><a title="sonic.client.SonicClient.__init__" href="#sonic.client.SonicClient.__init__">__init__</a></code></li>
<li><code><a title="sonic.client.SonicClient.address" href="#sonic.client.SonicClient.address">address</a></code></li>
<li><code><a title="sonic.client.SonicClient.close" href="#sonic.client.SonicClient.close">close</a></code></li>
<li><code><a title="sonic.client.SonicClient.connect" href="#sonic.client.SonicClient.connect">connect</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sonic.client.SonicServerError" href="#sonic.client.SonicServerError">SonicServerError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>